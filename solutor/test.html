<html>
<head>
	<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
	<script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
	<script src="path.js"></script>
	<script src="space.js"></script>
	<script src="gadgets.js"></script>
	<script src="levels/level4.js"></script>
</head>
<body>
	<div id="carlo"></div>

	<script>
	
	/**
	* DEFINIZIONE DELL'ALGORITMO
	*/
	var resolve = function(spaces){
		
		// STEP 1
		var elementsPosition = [];
		for(var i=0; i<elements.length; i++){
			elementsPosition[i] = 0;
		}
		elementsPosition[elements.length-1] = -1;
		
		var freeSpaces = [];
		for(var i in spaces){
			if(!gadgets[spaces[i].id]){
				freeSpaces.push(spaces[i]);
			}
		}
		
		// STEP 2
		var cycle = function(){
			elementsPosition = findElementsPosition(elements, freeSpaces, elementsPosition);
			if(elementsPosition != null){
				console.log('------ trying solution ------ ');
				for(var i in elementsPosition){
					console.log('------ ' + elements[i].name + ' in space ' + freeSpaces[elementsPosition[i]].id);
				}
				
				var gadgetsPositioned = {};
				for(var i in elementsPosition){
					gadgetsPositioned[freeSpaces[elementsPosition[i]].id] = elements[i];
				}
				
				var mazeDescriptor = {status: {sbe: [], eots: [], visited: {}, path: []}};
				mazeDescriptor.gadgets = $.extend({}, gadgets, gadgetsPositioned);
				
				for(var i in spaces){
					mazeDescriptor[spaces[i].id] = {enterFunctions: [], adiacents: []};
					for(var j in spaces[i].adiacents){
						mazeDescriptor[spaces[i].id].adiacents.push(spaces[i].adiacents[j]);
					}
					mazeDescriptor.status.visited[spaces[i].id] = false;
				}
				
				for(var i in mazeDescriptor.gadgets){
					mazeDescriptor.gadgets[i].applyTo(i, mazeDescriptor);
				}
				
				if(typeof doors != 'undefined'){
					var enterFunction = function(status){
						if(status.path.length >= 2){
							var spaceId = status.path.last;
							var lastSpaceId = status.path.get(-2);
							
							for(var j=0; j<doors.length; j++){
								if((doors[j][0] == spaceId && doors[j][1] == lastSpaceId) ||
										(doors[j][1] == spaceId && doors[j][0] == lastSpaceId)){
									status.keys--;
									
									status.sbe.push(function(s){
										if(s.keys < 0) return -1;
										return 0;
									});
									break;
								}
							}
						}
					};
					
					var doorsApplied = [];
					
					for(var i in doors){
						var idSpaceA = doors[i][0];
						var idSpaceB = doors[i][1];
						
						doorsApplied.indexOf(idSpaceA) == -1 && mazeDescriptor[idSpaceA].enterFunctions.push(enterFunction) && doorsApplied.push(idSpaceA);
						doorsApplied.indexOf(idSpaceB) == -1 && mazeDescriptor[idSpaceB].enterFunctions.push(enterFunction) && doorsApplied.push(idSpaceB);
					}
				}
				
				var response = algorythmCycle(mazeDescriptor);
				console.log('found ' + response.validPaths.length + ' solutions');
				response.print(document.getElementById('carlo'));
				
				setTimeout(cycle, 100);
			} else console.log('------ FINISHED ------');
		};
		
		cycle();
	};
	
	var findElementsPosition = function(elements, spaces, basePosition){
		var retVal = [];
		
		var base = spaces.length;
		var baseNumber = 0;

		for(var i=0; i<basePosition.length; i++){
			baseNumber += basePosition[i] * Math.pow(base, basePosition.length-i-1);
		}
		
		var isValid = true;
		
		do {
			retVal = [];
			isValid = true;
			baseNumber++;
			
			if(baseNumber >= Math.pow(base, basePosition.length)) return null;
			
			var _baseNum = baseNumber;
			for(var i=0; i<basePosition.length; i++){
				var value = Math.floor(_baseNum / Math.pow(base, basePosition.length-i-1));
				_baseNum -= value * Math.pow(base, basePosition.length-i-1);
				if(retVal.indexOf(value) != -1 || !spaces[value].isPlaceable(elements[i].name)){
					isValid = false;
					break;
				} 
				retVal.push(value);
			}
		} while(!isValid);
		
		return retVal;
	};
	
	var algorythmCycle = function(mazeDescriptor){
		var response = {
			print: function(container){
				var html = '<ul>';
				
				for(var i=0; i<this.validPaths.length; i++){
					html += '<li>(';
					
					var validPath = this.validPaths[i];
					for(var j=0; j<validPath.length; j++){
						html += validPath.get(j) + ', ';
					}
					
					html += ')</li>';
				}
				
				html += '</ul>';
				container.innerHTML += html;
			}
		};
		
		var validPaths = [];
		
		var paths = [new Path($.extend(true, {}, mazeDescriptor.status), mazeDescriptor.start)];
			
		while(paths.length > 0){
			var path = paths.pop();
			
			var adiacents = [];
			if(path.status.redirect){
				adiacents = path.status.redirect;
				path.status.redirect = null;
			} else {
				adiacents = mazeDescriptor[path.last].adiacents;
			};
			
			for(var j=0; j<adiacents.length; j++){
				var newSpaceId = adiacents[j];
				
				if(newSpaceId == 0) continue;
				
				if(path.contains(newSpaceId)) continue;
				
				var newPath = path.goto(newSpaceId);
				
				var enterFunctions = mazeDescriptor[newSpaceId].enterFunctions;
				for(var i=0; i<enterFunctions.length; i++){
					enterFunctions[i](newPath.status);
				}
				
				var imDead = false;
				var levelCompleted = false;
				
				for(var i=0; i<newPath.status.sbe.length; i++){
					if(newPath.status.sbe[i](newPath.status) < 0){
						imDead = true;
					} else if(newPath.status.sbe[i](newPath.status) > 0){
						levelCompleted = true;
					}
				}
				
				newPath.status.sbe = [];
				
				for(var i=0; i<newPath.status.eots.length; i++){
					newPath.status.eots[i](newPath.status);
				}
				newPath.status.eots = [];
				
				if(imDead && levelCompleted) levelCompleted = false;
		
				if(levelCompleted){
					validPaths.push(newPath);
				} else if(!imDead) {
					paths.push(newPath);
				}
			}
		}
		
		response.validPaths = validPaths;
		
		return response;
	};
	
	resolve(spaces);
</script>
	
	
</body>
</html>